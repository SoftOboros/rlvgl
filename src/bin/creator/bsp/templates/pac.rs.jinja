{# PAC BSP generation template for rlvgl-creator. #}
//! PAC-style BSP initialization for {{ spec.board or "Board" }}.
//!
//! Generated by rlvgl-creator.

{% macro port_u(pin) -%}{{ pin.pin[1] }}{%- endmacro %}
{% macro port_l(pin) -%}{{ pin.pin[1]|lower }}{%- endmacro %}
{% macro idx(pin) -%}{{ pin.pin[2:] | int }}{%- endmacro %}
{% macro kernel_clk(name, src) -%}
{%- if name == "usart1" -%}
dp.RCC.d2ccip2r.modify(|_, w| w.usart1sel().{{ src }}());
{%- elif name == "uart8" -%}
dp.RCC.d3ccipr.modify(|_, w| w.uart8sel().{{ src }}());
{%- elif name in ["spi1", "spi2", "spi3"] -%}
dp.RCC.d2ccip1r.modify(|_, w| w.spi123sel().{{ src }}());
{%- elif name in ["spi4", "spi5"] -%}
dp.RCC.d2ccip1r.modify(|_, w| w.spi45sel().{{ src }}());
{%- elif name == "i2c4" -%}
dp.RCC.d3ccipr.modify(|_, w| w.i2c4sel().{{ src }}());
{%- else -%}
// TODO: set {{ name }} kernel clock source to {{ src }}
{%- endif -%}
{%- endmacro %}

fn init_pac(dp: pac::Peripherals) {
    {%- if spec.clocks %}
    // Clock configuration
    {%- for name, pll in spec.clocks.pll | dictsort %}
    // Configure {{ name|upper }}
    dp.RCC.pllckselr.modify(|_, w| unsafe { w.div{{ name[3:] }}().bits({{ pll.m }}) });
    dp.RCC.{{ name }}divr.modify(|_, w| unsafe {
        w.{{ name }}n().bits({{ pll.n }} - 1);
        w.{{ name }}p().bits({{ pll.p }} - 1);
        w.{{ name }}q().bits({{ pll.q }} - 1);
        w.{{ name }}r().bits({{ pll.r }} - 1)
    });
    dp.RCC.cr.modify(|_, w| w.pll{{ name[3:] }}on().set_bit());
    while dp.RCC.cr.read().pll{{ name[3:] }}rdy().bit_is_clear() {}
    {%- endfor %}
    {%- for name, src in spec.clocks.kernels | dictsort %}
    {{ kernel_clk(name, src) }}
    {%- endfor %}
    {%- endif %}

    // Enable GPIO clocks
    {%- set ports = namespace(list=[]) %}
    {%- for pin in spec.pinctrl %}
        {%- set p = pin.pin[1] %}
        {%- if p not in ports.list %}
            {%- do ports.list.append(p) %}
        {%- endif %}
    {%- endfor %}
    {%- for p in ports.list %}
    dp.RCC.ahb4enr.modify(|_, w| w.gpio{{ p|lower }}en().set_bit());
    {%- endfor %}

    // Configure pins
    {%- for pin in spec.pinctrl %}
    // {{ pin.pin }} {{ pin.func }} AF{{ pin.af }}
    let shift = {{ idx(pin) }} * 2;
    {%- set is_gpio = pin.func[0:5] == "GPIO_" %}
    {%- set is_analog = pin.func[0:3] == "ADC" or ("Analog" in pin.func) %}
    {%- if is_gpio %}
    let moder_bits = {% if "Output" in pin.func %}0b01{% elif is_analog %}0b11{% else %}0b00{% endif %};
    {%- else %}
    let moder_bits = 0b10;
    {%- endif %}
    dp.GPIO{{ port_u(pin) }}.moder.modify(|r, w| unsafe {
        let mut bits = r.bits();
        bits &= !(0b11 << shift);
        bits |= moder_bits << shift;
        w.bits(bits)
    });
    dp.GPIO{{ port_u(pin) }}.pupdr.modify(|r, w| unsafe {
        let mut bits = r.bits();
        bits &= !(0b11 << shift);
        bits |= 0b00 << shift;
        w.bits(bits)
    });
    {%- if pin.func[0:3] == "I2C" %}
    dp.GPIO{{ port_u(pin) }}.otyper.modify(|r, w| unsafe {
        w.bits((r.bits() & !(1 << {{ idx(pin) }})) | (1 << {{ idx(pin) }}))
    });
    {%- else %}
    dp.GPIO{{ port_u(pin) }}.otyper.modify(|r, w| unsafe {
        w.bits(r.bits() & !(1 << {{ idx(pin) }}))
    });
    {%- endif %}
    {%- if not is_gpio and pin.af is not none %}
    let afr_shift = ({{ idx(pin) }} % 8) * 4;
    {%- if idx(pin) < 8 %}
    dp.GPIO{{ port_u(pin) }}.afrl.modify(|r, w| unsafe {
        let mut bits = r.bits();
        bits &= !(0xF << afr_shift);
        bits |= ({{ pin.af }}u32 & 0xF) << afr_shift;
        w.bits(bits)
    });
    {%- else %}
    dp.GPIO{{ port_u(pin) }}.afrh.modify(|r, w| unsafe {
        let mut bits = r.bits();
        bits &= !(0xF << afr_shift);
        bits |= ({{ pin.af }}u32 & 0xF) << afr_shift;
        w.bits(bits)
    });
    {%- endif %}
    {%- endif %}
    {%- endfor %}

    // Peripheral enables
    {%- for name, _per in spec.peripherals | dictsort %}
    {%- if name == "i2c4" %}
    dp.RCC.apb4enr.modify(|_, w| w.i2c4en().set_bit());
    {%- elif name == "spi2" %}
    dp.RCC.apb1lenr.modify(|_, w| w.spi2en().set_bit());
    {%- elif name == "spi5" %}
    dp.RCC.apb2enr.modify(|_, w| w.spi5en().set_bit());
    {%- elif name == "uart8" %}
    dp.RCC.apb1henr.modify(|_, w| w.uart8en().set_bit());
    {%- elif name == "usart1" %}
    dp.RCC.apb2enr.modify(|_, w| w.usart1en().set_bit());
    {%- else %}
    // TODO: enable {{ name|upper }} clock
    {%- endif %}
    {%- endfor %}
}
