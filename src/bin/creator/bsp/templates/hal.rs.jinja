{# HAL BSP generation template for rlvgl-creator. #}
/* Auto-generated by rlvgl-creator
 * SPDX-FileCopyrightText: 2020 STMicroelectronics
 * SPDX-FileCopyrightText: 2025 Softoboros Technology, Inc.
 * SPDX-License-Identifier: BSD-3-Clause
 * Provenance: STM32_open_pin_data (commit <hash>), build <build-hash>.
 */
#![allow(non_snake_case)]
#![allow(clippy::too_many_arguments)]
{% if mod_name %}#![cfg(feature = "{{ mod_name }}")]{% endif %}

use stm32h7xx_hal::{pac, prelude::*};

{% macro gpio_bus(family) -%}
{% if family.startswith("STM32H7") %}ahb4enr
{% elif family.startswith("STM32H5") or family.startswith("STM32L5") or family.startswith("STM32L4") or family.startswith("STM32G4") %}ahb2enr
{% elif family.startswith("STM32G0") or family.startswith("STM32L0") %}iopenr
{% elif family.startswith("STM32F1") %}apb2enr
{% elif family.startswith("STM32F0") or family.startswith("STM32F3") or family.startswith("STM32L1") %}ahbenr
{% else %}ahb1enr{% endif %}
{%- endmacro %}
{% macro port_bit(p) -%}
{% set map = {"A":0,"B":1,"C":2,"D":3,"E":4,"F":5,"G":6,"H":7,"I":8,"J":9,"K":10} %}
{{ map[p] }}
{%- endmacro %}
{% macro port_l(pin) -%}{{ pin.pin[1]|lower }}{%- endmacro %}
{% macro field(pin) -%}p{{ pin.pin[1:]|lower }}{%- endmacro %}
{% macro port_u(pin) -%}{{ pin.pin[1] }}{%- endmacro %}
{% macro idx(pin) -%}{{ pin.pin[2:] | int }}{%- endmacro %}
{% macro kernel_clk(name, src) -%}
{%- if name == "usart1" -%}
    dp.RCC.d2ccip2r.modify(|_, w| w.usart1sel().{{ src }}());
{%- elif name == "uart8" -%}
    dp.RCC.d3ccipr.modify(|_, w| w.uart8sel().{{ src }}());
{%- elif name in ["spi1", "spi2", "spi3"] -%}
    dp.RCC.d2ccip1r.modify(|_, w| w.spi123sel().{{ src }}());
{%- elif name in ["spi4", "spi5"] -%}
    dp.RCC.d2ccip1r.modify(|_, w| w.spi45sel().{{ src }}());
{%- elif name == "i2c4" -%}
    dp.RCC.d3ccipr.modify(|_, w| w.i2c4sel().{{ src }}());
{%- else -%}
    // TODO: set {{ name }} kernel clock source to {{ src }}
{%- endif -%}
{%- endmacro %}

pub fn enable_gpio_clocks(dp: &pac::Peripherals) {
    {% set ports = [] %}{% for pin in spec.pinctrl %}{% if pin.pin[1] not in ports %}{% do ports.append(pin.pin[1]) %}{% endif %}{% endfor %}
    {% if grouped_writes %}
    dp.RCC.{{ gpio_bus(spec.mcu.family) }}.modify(|r, w| unsafe {
        let mut bits = r.bits();
        bits |= {% for p in ports %}(1 << {{ port_bit(p) }}){% if not loop.last %} | {% endif %}{% endfor %};
        w.bits(bits)
    });
    {% else %}
    {%- for p in ports %}
    dp.RCC.{{ gpio_bus(spec.mcu.family) }}.modify(|_, w| w.gpio{{ p|lower }}en().set_bit());
    {%- endfor %}
    {% endif %}
}

pub fn configure_pins_hal() {
{%- for pin in spec.pinctrl %}
    {%- set is_gpio = pin.func[0:5] == "GPIO_" %}
    {%- set is_i2c  = pin.func[0:3] == "I2C" %}
    {%- set is_ana  = pin.func[0:3] == "ADC" or ("Analog" in pin.func) %}
    // {{ pin.pin }} {{ pin.func }} AF{{ pin.af }}
    let {{ pin.pin | lower }} =
    {%- if is_gpio %}
        {%- if "Output" in pin.func %} gpio{{ port_l(pin) }}.{{ field(pin) }}.into_push_pull_output()
        {%- elif "Input" in pin.func %}  gpio{{ port_l(pin) }}.{{ field(pin) }}.into_floating_input()
        {%- elif is_ana %}               gpio{{ port_l(pin) }}.{{ field(pin) }}.into_analog()
        {%- else %}                      gpio{{ port_l(pin) }}.{{ field(pin) }}.into_floating_input()
        {%- endif -%}
    {%- else %}
        {%- if is_i2c %}                 gpio{{ port_l(pin) }}.{{ field(pin) }}.into_alternate_open_drain::<{{ pin.af }}>()
        {%- else %}                      gpio{{ port_l(pin) }}.{{ field(pin) }}.into_alternate::<{{ pin.af }}>()
        {%- endif -%}
    {%- endif %};
{%- endfor %}
}

pub fn enable_peripherals(dp: &pac::Peripherals) {
{%- set regs = {} -%}
{%- for name, _per in spec.peripherals | dictsort %}
    {%- if spec.mcu.family.startswith("STM32H7") %}
        {%- if name == "i2c4" %}{% set reg = "apb4enr" %}{% set field = "i2c4en" %}
        {%- elif name == "spi2" %}{% set reg = "apb1lenr" %}{% set field = "spi2en" %}
        {%- elif name == "spi5" %}{% set reg = "apb2enr" %}{% set field = "spi5en" %}
        {%- elif name == "uart8" %}{% set reg = "apb1henr" %}{% set field = "uart8en" %}
        {%- elif name == "usart1" %}{% set reg = "apb2enr" %}{% set field = "usart1en" %}
        {%- else %}{% set reg = None %}{% set field = None %}
        {%- endif %}
    {%- elif spec.mcu.family.startswith("STM32H5") %}
        {%- if name in ["usart1", "spi1"] %}{% set reg = "apb2enr" %}{% set field = name ~ "en" %}
        {%- else %}{% set reg = "apb1enr1" %}{% set field = name ~ "en" %}
        {%- endif %}
    {%- elif spec.mcu.family.startswith("STM32F") or spec.mcu.family.startswith("STM32L") or spec.mcu.family.startswith("STM32G") %}
        {%- if name in ["spi1", "spi4", "spi5", "spi6", "usart1", "usart6"] %}
            {% set reg = "apb2enr" %}
        {%- elif name.startswith("spi") or name.startswith("usart") or name.startswith("uart") or name.startswith("i2c") %}
            {% set reg = "apb1enr" %}
        {%- else %}{% set reg = None %}{% endif %}
        {%- if reg %}{% set field = name ~ "en" %}{% else %}{% set field = None %}{% endif %}
    {%- else %}
        {% set reg = None %}{% set field = None %}
    {%- endif %}
    {%- if reg and field %}
        {%- if reg in regs %}{% do regs[reg].append(field) %}{% else %}{% set _ = regs.update({reg:[field]}) %}{% endif %}
    {%- endif %}
{%- endfor %}
{% if grouped_writes %}
{%- for reg, fields in regs.items() %}
    dp.RCC.{{ reg }}.modify(|_, w| w{% for f in fields %}.{{ f }}().set_bit(){% endfor %});
{%- endfor %}
{% else %}
{%- for reg, fields in regs.items() %}
    {%- for f in fields %}
    dp.RCC.{{ reg }}.modify(|_, w| w.{{ f }}().set_bit());
    {%- endfor %}
{%- endfor %}
{% endif %}
}

{% if with_deinit %}
pub fn deinit_board_hal(dp: &pac::Peripherals) {
    // Return pins to analog and remove pulls/open-drain
{%- for pin in spec.pinctrl %}
    let shift = {{ idx(pin) }} * 2;
    dp.GPIO{{ port_u(pin) }}.moder.modify(|r, w| unsafe {
        let mut bits = r.bits() & !(0b11 << shift);
        bits |= 0b11 << shift;
        w.bits(bits)
    });
    dp.GPIO{{ port_u(pin) }}.pupdr.modify(|r, w| unsafe { w.bits(r.bits() & !(0b11 << shift)) });
    dp.GPIO{{ port_u(pin) }}.otyper.modify(|r, w| unsafe { w.bits(r.bits() & !(1 << {{ idx(pin) }})) });
{%- endfor %}

    // Gate peripheral clocks
{%- set regs = {} -%}
{%- for name, _per in spec.peripherals | dictsort %}
    {%- if spec.mcu.family.startswith("STM32H7") %}
        {%- if name == "i2c4" %}{% set reg = "apb4enr" %}{% set field = "i2c4en" %}
        {%- elif name == "spi2" %}{% set reg = "apb1lenr" %}{% set field = "spi2en" %}
        {%- elif name == "spi5" %}{% set reg = "apb2enr" %}{% set field = "spi5en" %}
        {%- elif name == "uart8" %}{% set reg = "apb1henr" %}{% set field = "uart8en" %}
        {%- elif name == "usart1" %}{% set reg = "apb2enr" %}{% set field = "usart1en" %}
        {%- else %}{% set reg = None %}{% set field = None %}
        {%- endif %}
    {%- elif spec.mcu.family.startswith("STM32H5") %}
        {%- if name in ["usart1", "spi1"] %}{% set reg = "apb2enr" %}{% set field = name ~ "en" %}
        {%- else %}{% set reg = "apb1enr1" %}{% set field = name ~ "en" %}
        {%- endif %}
    {%- elif spec.mcu.family.startswith("STM32F") or spec.mcu.family.startswith("STM32L") or spec.mcu.family.startswith("STM32G") %}
        {%- if name in ["spi1", "spi4", "spi5", "spi6", "usart1", "usart6"] %}
            {% set reg = "apb2enr" %}
        {%- elif name.startswith("spi") or name.startswith("usart") or name.startswith("uart") or name.startswith("i2c") %}
            {% set reg = "apb1enr" %}
        {%- else %}{% set reg = None %}{% endif %}
        {%- if reg %}{% set field = name ~ "en" %}{% else %}{% set field = None %}{% endif %}
    {%- else %}
        {% set reg = None %}{% set field = None %}
    {%- endif %}
    {%- if reg and field %}
        {%- if reg in regs %}{% do regs[reg].append(field) %}{% else %}{% set _ = regs.update({reg:[field]}) %}{% endif %}
    {%- endif %}
{%- endfor %}
{%- for reg, fields in regs.items() %}
    dp.RCC.{{ reg }}.modify(|_, w| w{% for f in fields %}.{{ f }}().clear_bit(){% endfor %});
{%- endfor %}

    {%- set dmas = [] %}
    {%- set bdmas = [] %}
    {%- set mdmas = [] %}
    {%- for name, _per in spec.peripherals | dictsort %}
        {%- if name.startswith("dma") %}{% do dmas.append(name|upper) %}
        {%- elif name.startswith("bdma") %}{% do bdmas.append(name|upper) %}
        {%- elif name.startswith("mdma") %}{% do mdmas.append(name|upper) %}
        {%- endif %}
    {%- endfor %}
    {%- set channel_dma = spec.mcu.family.startswith("STM32F0") or spec.mcu.family.startswith("STM32F1") or spec.mcu.family.startswith("STM32F3") or spec.mcu.family.startswith("STM32L0") or spec.mcu.family.startswith("STM32L1") or spec.mcu.family.startswith("STM32G0") %}

    // Disable DMA controllers and mask their interrupts
    {%- if dmas %}
    dp.RCC.{{ "ahbenr" if channel_dma else "ahb1enr" }}.modify(|_, w| w{% for dma in dmas %}.{{ dma|lower }}en().clear_bit(){% endfor %});
    {%- for dma in dmas %}
        {%- if channel_dma %}
            {%- for i in range(1,8) %}
    unsafe { pac::NVIC::mask(pac::Interrupt::{{ dma }}_CHANNEL{{ i }}); }
            {%- endfor %}
    dp.{{ dma }}.ifcr.write(|w| unsafe { w.bits(0xFFFF_FFFF) });
            {%- for i in range(1,8) %}
    dp.{{ dma }}.ch[{{ i }}].ccr.write(|w| unsafe { w.bits(0) });
    dp.{{ dma }}.ch[{{ i }}].cndtr.write(|w| unsafe { w.bits(0) });
    dp.{{ dma }}.ch[{{ i }}].cpar.write(|w| unsafe { w.bits(0) });
    dp.{{ dma }}.ch[{{ i }}].cmar.write(|w| unsafe { w.bits(0) });
            {%- endfor %}
        {%- else %}
            {%- for i in range(0,8) %}
    unsafe { pac::NVIC::mask(pac::Interrupt::{{ dma }}_STREAM{{ i }}); }
            {%- endfor %}
    dp.{{ dma }}.lifcr.write(|w| unsafe { w.bits(0xFFFF_FFFF) });
    dp.{{ dma }}.hifcr.write(|w| unsafe { w.bits(0xFFFF_FFFF) });
            {%- for i in range(0,8) %}
    dp.{{ dma }}.st[{{ i }}].cr.write(|w| unsafe { w.bits(0) });
    dp.{{ dma }}.st[{{ i }}].ndtr.write(|w| unsafe { w.bits(0) });
    dp.{{ dma }}.st[{{ i }}].par.write(|w| unsafe { w.bits(0) });
    dp.{{ dma }}.st[{{ i }}].m0ar.write(|w| unsafe { w.bits(0) });
    dp.{{ dma }}.st[{{ i }}].m1ar.write(|w| unsafe { w.bits(0) });
    dp.{{ dma }}.st[{{ i }}].fcr.write(|w| unsafe { w.bits(0) });
            {%- endfor %}
        {%- endif %}
    {%- endfor %}
    {%- endif %}

    {%- if bdmas %}
    dp.RCC.ahb4enr.modify(|_, w| w{% for bdma in bdmas %}.{{ bdma|lower }}en().clear_bit(){% endfor %});
    {%- for bdma in bdmas %}
        {%- for i in range(0,8) %}
    unsafe { pac::NVIC::mask(pac::Interrupt::{{ bdma }}_CHANNEL{{ i }}); }
    dp.{{ bdma }}.ifcr.write(|w| unsafe { w.bits(0xFFFF_FFFF) });
    dp.{{ bdma }}.ch[{{ i }}].cr.write(|w| unsafe { w.bits(0) });
    dp.{{ bdma }}.ch[{{ i }}].bndtr.write(|w| unsafe { w.bits(0) });
    dp.{{ bdma }}.ch[{{ i }}].sar.write(|w| unsafe { w.bits(0) });
    dp.{{ bdma }}.ch[{{ i }}].dar.write(|w| unsafe { w.bits(0) });
        {%- endfor %}
    {%- endfor %}
    {%- endif %}

    {%- if mdmas %}
    dp.RCC.ahb3enr.modify(|_, w| w{% for mdma in mdmas %}.{{ mdma|lower }}en().clear_bit(){% endfor %});
    {%- for mdma in mdmas %}
    unsafe { pac::NVIC::mask(pac::Interrupt::{{ mdma }}); }
        {%- for i in range(0,16) %}
    dp.{{ mdma }}.ch[{{ i }}].cr.write(|w| unsafe { w.bits(0) });
    dp.{{ mdma }}.ch[{{ i }}].tcr.write(|w| unsafe { w.bits(0) });
    dp.{{ mdma }}.ch[{{ i }}].bndtr.write(|w| unsafe { w.bits(0) });
    dp.{{ mdma }}.ch[{{ i }}].sar.write(|w| unsafe { w.bits(0) });
    dp.{{ mdma }}.ch[{{ i }}].dar.write(|w| unsafe { w.bits(0) });
    dp.{{ mdma }}.ch[{{ i }}].brur.write(|w| unsafe { w.bits(0) });
    dp.{{ mdma }}.ch[{{ i }}].lar.write(|w| unsafe { w.bits(0) });
    dp.{{ mdma }}.ch[{{ i }}].tbr.write(|w| unsafe { w.bits(0) });
    dp.{{ mdma }}.ch[{{ i }}].mar.write(|w| unsafe { w.bits(0) });
    dp.{{ mdma }}.ch[{{ i }}].mdr.write(|w| unsafe { w.bits(0) });
        {%- endfor %}
    {%- endfor %}
    {%- endif %}

    // Disable interrupts
{%- macro irq_list(name) -%}
{%- if name == "i2c4" -%}["I2C4_EV", "I2C4_ER"]
{%- elif name == "spi2" -%}["SPI2"]
{%- elif name == "spi5" -%}["SPI5"]
{%- elif name == "uart8" -%}["UART8"]
{%- elif name == "usart1" -%}["USART1"]
{%- else -%}[]
{%- endif -%}
{%- endmacro %}
{%- for name, _per in spec.peripherals | dictsort %}
    {%- for irq in irq_list(name) %}
    unsafe { pac::NVIC::mask(pac::Interrupt::{{ irq }}); }
    {%- endfor %}
{%- endfor %}
}
{% endif %}

pub fn init_board_hal(dp: pac::Peripherals /*, clocks */) {
    enable_gpio_clocks(&dp);
    configure_pins_hal();
    enable_peripherals(&dp);
}
