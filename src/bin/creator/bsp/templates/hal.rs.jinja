{# HAL BSP generation template for rlvgl-creator. #}
//! HAL-style BSP initialization for {{ spec.board or "Board" }}.
//!
//! Generated by rlvgl-creator.

{% macro port_l(pin) -%}{{ pin.pin[1]|lower }}{%- endmacro %}
{% macro field(pin) -%}p{{ pin.pin[1:]|lower }}{%- endmacro %}
{% macro kernel_clk(name, src) -%}
{%- if name == "usart1" -%}
dp.RCC.d2ccip2r.modify(|_, w| w.usart1sel().{{ src }}());
{%- elif name == "uart8" -%}
dp.RCC.d3ccipr.modify(|_, w| w.uart8sel().{{ src }}());
{%- elif name in ["spi1", "spi2", "spi3"] -%}
dp.RCC.d2ccip1r.modify(|_, w| w.spi123sel().{{ src }}());
{%- elif name in ["spi4", "spi5"] -%}
dp.RCC.d2ccip1r.modify(|_, w| w.spi45sel().{{ src }}());
{%- elif name == "i2c4" -%}
dp.RCC.d3ccipr.modify(|_, w| w.i2c4sel().{{ src }}());
{%- else -%}
// TODO: set {{ name }} kernel clock source to {{ src }}
{%- endif -%}
{%- endmacro %}

// Split your GPIO ports here (crate-specific).
// let gpioa = dp.GPIOA.split(/* ... */);
// let gpiob = dp.GPIOB.split(/* ... */);
// ...

{%- if spec.clocks %}
// Clock configuration
{%- for name, pll in spec.clocks.pll | dictsort %}
// PLL{{ name }}: m{{ pll.m }} n{{ pll.n }} p{{ pll.p }} q{{ pll.q }} r{{ pll.r }}
{%- endfor %}
  {%- for name, src in spec.clocks.kernels | dictsort %}
  {{ kernel_clk(name, src) }}
  {%- endfor %}
{%- endif %}

{%- for pin in spec.pinctrl %}
{%- set is_gpio = pin.func[0:5] == "GPIO_" %}
{%- set is_i2c  = pin.func[0:3] == "I2C" %}
{%- set is_ana  = pin.func[0:3] == "ADC" or ("Analog" in pin.func) %}
// {{ pin.pin }} {{ pin.func }} AF{{ pin.af }}
let {{ pin.pin | lower }} =
{%- if is_gpio %}
  {%- if "Output" in pin.func %} gpio{{ port_l(pin) }}.{{ field(pin) }}.into_push_pull_output()
  {%- elif "Input" in pin.func %}  gpio{{ port_l(pin) }}.{{ field(pin) }}.into_floating_input()
  {%- elif is_ana %}               gpio{{ port_l(pin) }}.{{ field(pin) }}.into_analog()
  {%- else %}                      gpio{{ port_l(pin) }}.{{ field(pin) }}.into_floating_input()
  {%- endif -%}
{%- else %}
  {%- if is_i2c %}                 gpio{{ port_l(pin) }}.{{ field(pin) }}.into_alternate_open_drain::<{{ pin.af }}>()
  {%- else %}                      gpio{{ port_l(pin) }}.{{ field(pin) }}.into_alternate::<{{ pin.af }}>()
  {%- endif -%}
{%- endif %};
{%- endfor %}

// Peripheral clock enables
{%- for name, _per in spec.peripherals | dictsort %}
{%- if name == "i2c4" %}
dp.RCC.apb4enr.modify(|_, w| w.i2c4en().set_bit());
{%- elif name == "spi2" %}
dp.RCC.apb1lenr.modify(|_, w| w.spi2en().set_bit());
{%- elif name == "spi5" %}
dp.RCC.apb2enr.modify(|_, w| w.spi5en().set_bit());
{%- elif name == "uart8" %}
dp.RCC.apb1henr.modify(|_, w| w.uart8en().set_bit());
{%- elif name == "usart1" %}
dp.RCC.apb2enr.modify(|_, w| w.usart1en().set_bit());
{%- else %}
// TODO: enable {{ name|upper }} clock
{%- endif %}
{%- endfor %}

{%- for name, per in spec.peripherals | dictsort %}

{%- if per.class == "serial" %}
// {{ name|upper }}
let {{ name }} = Serial::{{ name }}(
    dp.{{ name|upper }},
    ( {{ per.signals.tx | lower }}, {{ per.signals.rx | lower }} ),
    115_200.bps(),
    &clocks
);

{%- elif per.class == "spi" %}
// {{ name|upper }}
let {{ name }} = Spi::{{ name }}(
    dp.{{ name|upper }},
    ( {{ per.signals.sck | lower }}, {{ per.signals.miso | lower }}, {{ per.signals.mosi | lower }} ),
    embedded_hal::spi::MODE_0,
    12.MHz(),
    &clocks
);
let _{{ name }}_nss = {{ per.signals.nss | lower }};

{%- elif per.class == "i2c" %}
// {{ name|upper }}
let {{ name }} = I2c::{{ name }}(
    dp.{{ name|upper }},
    ( {{ per.signals.scl | lower }}, {{ per.signals.sda | lower }} ),
    400.kHz(),
    &clocks
);
{%- endif %}

{%- endfor %}
