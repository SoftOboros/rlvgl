//! Scaffold command for rlvgl-creator.
//!
//! Generates a dual-mode assets crate using embedded Tera templates.

use std::collections::BTreeMap;
use std::fs;
use std::path::Path;

use anyhow::{Result, bail};
use tera::{Context, Tera};

use crate::manifest::Manifest;
use serde_yaml;

/// Generate a new assets crate populated from the manifest.
pub(crate) fn run(path: &Path, manifest_path: &Path) -> Result<()> {
    if path.exists() {
        bail!("`{}` already exists", path.display());
    }

    let crate_name = path
        .file_name()
        .ok_or_else(|| anyhow::anyhow!("invalid crate path"))?
        .to_string_lossy()
        .into_owned();

    fs::create_dir_all(path.join("src"))?;

    let manifest: Manifest = if manifest_path.exists() {
        let contents = fs::read_to_string(manifest_path)?;
        serde_yaml::from_str(&contents)?
    } else {
        Manifest::default()
    };

    let mut groups: Vec<String> = manifest.groups.keys().map(|g| g.to_lowercase()).collect();
    groups.sort();

    // Map each asset path to the groups that reference it so constants can be feature gated.
    let mut per_asset_groups: BTreeMap<String, Vec<String>> = BTreeMap::new();
    for (group, info) in &manifest.groups {
        for asset in &info.assets {
            per_asset_groups
                .entry(asset.clone())
                .or_default()
                .push(group.to_lowercase());
        }
    }

    #[derive(serde::Serialize)]
    struct EmbedAsset {
        name: String,
        path: String,
        features: Vec<String>,
    }

    let mut embed_assets = Vec::new();
    for asset in &manifest.assets {
        embed_assets.push(EmbedAsset {
            name: asset.name.clone(),
            path: asset.path.clone(),
            features: per_asset_groups
                .get(&asset.path)
                .cloned()
                .unwrap_or_default(),
        });
    }

    let mut tera = Tera::default();
    const CARGO_TOML: &str = r#"[package]
name = "{{ name }}"
version = "0.1.0"
edition = "2024"
publish = false
description = "Assets crate generated by rlvgl-creator"

[features]
default = []
embed = []
vendor = []
{% for g in groups %}{{ g }} = []
{% endfor %}"#;
    const LIB_RS: &str = r#"#![no_std]
#![deny(missing_docs)]

/// Assets crate generated by rlvgl-creator.

#[cfg(feature = "embed")]
/// Embedded asset bytes.
pub mod embed {
    {% for a in assets %}
    {% if a.features | length > 0 %}
    #[cfg(any({% for f in a.features %}feature = "{{ f }}"{% if !loop.last %}, {% endif %}{% endfor %}))]
    {% endif %}
    pub const {{ a.name }}: &[u8] = include_bytes!(concat!(env!("CARGO_MANIFEST_DIR"), "/../{{ a.path }}"));
    {% endfor %}
}

#[cfg(feature = "vendor")]
/// Vendor build helpers.
pub mod vendor {
    use std::path::Path;

    /// Copy all assets into `out_dir`.
    pub fn copy_all(out_dir: &Path) -> std::io::Result<()> {
        vendor_api::copy_all(out_dir, ASSETS)
    }

    /// Generate an `rlvgl_assets.rs` module under `out_dir`.
    pub fn generate_rust_module(out_dir: &Path) -> std::io::Result<()> {
        vendor_api::generate_rust_module(out_dir, ASSETS)
    }

    const ASSETS: &[(&str, &str)] = &[
    {% for a in assets %}
        ("{{ a.name }}", "{{ a.path }}"),
    {% endfor %}
    ];

    mod vendor_api {
        use std::fs;
        use std::path::Path;

        pub fn copy_all(out_dir: &Path, assets: &[(&str, &str)]) -> std::io::Result<()> {
            let root = Path::new(env!("CARGO_MANIFEST_DIR")).join("../");
            for (_, path) in assets {
                let src = root.join(path);
                let dest = out_dir.join(path);
                if let Some(parent) = dest.parent() {
                    fs::create_dir_all(parent)?;
                }
                fs::copy(&src, &dest)?;
            }
            Ok(())
        }

        pub fn generate_rust_module(out_dir: &Path, assets: &[(&str, &str)]) -> std::io::Result<()> {
            let mut module = String::from("//! Auto-generated asset constants\n\n");
            for (name, path) in assets {
                module.push_str(&format!("pub const {}: &[u8] = include_bytes!(\"{}\");\n", name, path));
            }
            fs::write(out_dir.join("rlvgl_assets.rs"), module)?;
            Ok(())
        }
    }
}
"#;
    const README_MD: &str = r#"# {{ name }}

This crate was generated by `rlvgl-creator`.

## Embed

Enable the `embed` feature and reference asset constants directly:

```rust
use {{ name }}::embed::SOME_ASSET;
```

## Vendor

Enable the `vendor` feature and call the helpers from `build.rs`:

```rust
fn main() {
    let out = std::path::Path::new(&std::env::var("OUT_DIR").unwrap());
    {{ name }}::vendor::copy_all(out).unwrap();
    {{ name }}::vendor::generate_rust_module(out).unwrap();
}
```
"#;
    tera.add_raw_template("Cargo.toml", CARGO_TOML)?;
    tera.add_raw_template("lib.rs", LIB_RS)?;
    tera.add_raw_template("README.md", README_MD)?;

    let mut ctx = Context::new();
    ctx.insert("name", &crate_name);
    ctx.insert("groups", &groups);
    ctx.insert("assets", &embed_assets);

    fs::write(path.join("Cargo.toml"), tera.render("Cargo.toml", &ctx)?)?;
    fs::write(path.join("src/lib.rs"), tera.render("lib.rs", &ctx)?)?;
    fs::write(path.join("README.md"), tera.render("README.md", &ctx)?)?;

    println!("Scaffolded crate `{}`", crate_name);
    Ok(())
}
