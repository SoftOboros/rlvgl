/* Auto-generated by rlvgl-creator
 * SPDX-FileCopyrightText: 2020 STMicroelectronics
 * SPDX-FileCopyrightText: 2025 Softoboros Technology, Inc.
 * SPDX-License-Identifier: BSD-3-Clause
 * Provenance: STM32_open_pin_data (commit <hash>), build <build-hash>.
 
 */
#![allow(non_snake_case)]
#![allow(clippy::too_many_arguments)]

use stm32h7::stm32h747cm7 as pac;

/// Enable AHB4 clocks for all GPIO banks.
pub fn enable_gpio_clocks(dp: &pac::Peripherals) {
    for bit in 0..=10 {
        dp.RCC
            .ahb4enr
            .modify(|r, w| unsafe { w.bits(r.bits() | (1 << bit)) });
    }
}

/// Configure GPIO alternate functions using the generated PAC helper.
pub fn configure_pins_hal(dp: &pac::Peripherals) {
    crate::bsp_pac::configure_pins_pac(dp);
}

/// Enable clocks for non-GPIO peripherals used by the board.
pub fn enable_peripherals(dp: &pac::Peripherals) {
    // I2C4 clock on APB4ENR bit 7
    dp.RCC
        .apb4enr
        .modify(|r, w| unsafe { w.bits(r.bits() | (1 << 7)) });
    // SPI2 clock on APB1LENR bit 14
    dp.RCC
        .apb1lenr
        .modify(|r, w| unsafe { w.bits(r.bits() | (1 << 14)) });
    // SPI5 clock on APB2ENR bit 20
    dp.RCC
        .apb2enr
        .modify(|r, w| unsafe { w.bits(r.bits() | (1 << 20)) });
}

/// Initialize board-specific clocks and pin muxing using the generated helpers.
pub fn init_board_hal(dp: &pac::Peripherals /*, clocks */) {
    enable_gpio_clocks(dp);
    configure_pins_hal(dp);
    enable_peripherals(dp);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[repr(transparent)]
    #[derive(Default)]
    struct Reg(u32);

    struct RegR(u32);
    impl RegR {
        fn bits(&self) -> u32 {
            self.0
        }
    }

    struct RegW(u32);
    impl RegW {
        unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.0 = bits;
            self
        }
    }

    impl Reg {
        fn modify<F>(&mut self, f: F)
        where
            F: FnOnce(&RegR, &mut RegW) -> &mut RegW,
        {
            let r = RegR(self.0);
            let mut w = RegW(self.0);
            f(&r, &mut w);
            self.0 = w.0;
        }
    }

    #[repr(C)]
    #[derive(Default)]
    struct MockRcc {
        ahb4enr: Reg,
        apb1lenr: Reg,
        apb2enr: Reg,
        apb4enr: Reg,
    }

    #[repr(C)]
    #[derive(Default)]
    struct MockPeripherals {
        RCC: MockRcc,
    }

    #[test]
    fn gpio_clocks_enabled() {
        let mut dp = MockPeripherals::default();
        unsafe {
            enable_gpio_clocks(&*(
                &mut dp as *mut MockPeripherals as *mut pac::Peripherals
            ));
        }
        assert_eq!(dp.RCC.ahb4enr.0, 0x7ff);
    }

    #[test]
    fn peripheral_clocks_enabled() {
        let mut dp = MockPeripherals::default();
        unsafe {
            enable_peripherals(&*(
                &mut dp as *mut MockPeripherals as *mut pac::Peripherals
            ));
        }
        assert_eq!(dp.RCC.apb4enr.0 & (1 << 7), 1 << 7);
        assert_eq!(dp.RCC.apb1lenr.0 & (1 << 14), 1 << 14);
        assert_eq!(dp.RCC.apb2enr.0 & (1 << 20), 1 << 20);
    }
}
