/* Auto-generated by rlvgl-creator
* SPDX-FileCopyrightText: 2020 STMicroelectronics
* SPDX-FileCopyrightText: 2025 Softoboros Technology, Inc.
* SPDX-License-Identifier: BSD-3-Clause
* Provenance: STM32_open_pin_data (commit <hash>), build <build-hash>.

*/

//! PAC BSP for the generated board.

#![allow(non_snake_case)]
#![allow(clippy::too_many_arguments)]
#![cfg(feature = "usart2")]

use stm32mp1::stm32mp1135 as pac;

/// Enables GPIO clocks required by the generated board.

pub fn enable_gpio_clocks(dp: &pac::Peripherals) {
    const MASK: u32 = (1u32 << 3) | (1u32 << 4) | (1u32 << 7);
    dp.RCC
        .ahb1enr
        .modify(|r, w| unsafe { w.bits(r.bits() | MASK) });
}

/// Configures pins using PAC registers.

pub fn configure_pins_pac(dp: &pac::Peripherals) {
    // GPIOD
    dp.GPIOD.pupdr.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let shift = 15 * 2;
        bits &= !(0b11 << shift);
        bits |= 0b00 << shift;
        let shift = 4 * 2;
        bits &= !(0b11 << shift);
        bits |= 0b00 << shift;
        w.bits(bits)
    });
    dp.GPIOD.otyper.modify(|r, w| unsafe {
        let mut bits = r.bits();
        bits &= !(1 << 15);
        bits &= !(1 << 4);
        w.bits(bits)
    });
    dp.GPIOD.ospeedr.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let shift = 15 * 2;
        bits &= !(0b11 << shift);
        let shift = 4 * 2;
        bits &= !(0b11 << shift);
        w.bits(bits)
    });
    dp.GPIOD.afrl.modify(|r, w| unsafe {
        let mut bits = r.bits();
        w.bits(bits)
    });
    dp.GPIOD.afrh.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let afr_shift = (15 % 8) * 4;
        bits &= !(0xF << afr_shift);
        bits |= (0u32 & 0xF) << afr_shift;
        let afr_shift = (4 % 8) * 4;
        bits &= !(0xF << afr_shift);
        bits |= (0u32 & 0xF) << afr_shift;
        w.bits(bits)
    });
    dp.GPIOD.moder.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let shift = 15 * 2;
        bits &= !(0b11 << shift);
        bits |= 0b10 << shift;
        let shift = 4 * 2;
        bits &= !(0b11 << shift);
        bits |= 0b10 << shift;
        w.bits(bits)
    });

    // GPIOE
    dp.GPIOE.pupdr.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let shift = 11 * 2;
        bits &= !(0b11 << shift);
        bits |= 0b00 << shift;
        w.bits(bits)
    });
    dp.GPIOE.otyper.modify(|r, w| unsafe {
        let mut bits = r.bits();
        bits &= !(1 << 11);
        w.bits(bits)
    });
    dp.GPIOE.ospeedr.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let shift = 11 * 2;
        bits &= !(0b11 << shift);
        w.bits(bits)
    });
    dp.GPIOE.afrl.modify(|r, w| unsafe {
        let mut bits = r.bits();
        w.bits(bits)
    });
    dp.GPIOE.afrh.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let afr_shift = (11 % 8) * 4;
        bits &= !(0xF << afr_shift);
        bits |= (0u32 & 0xF) << afr_shift;
        w.bits(bits)
    });
    dp.GPIOE.moder.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let shift = 11 * 2;
        bits &= !(0b11 << shift);
        bits |= 0b10 << shift;
        w.bits(bits)
    });

    // GPIOH
    dp.GPIOH.pupdr.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let shift = 12 * 2;
        bits &= !(0b11 << shift);
        bits |= 0b00 << shift;
        w.bits(bits)
    });
    dp.GPIOH.otyper.modify(|r, w| unsafe {
        let mut bits = r.bits();
        bits &= !(1 << 12);
        w.bits(bits)
    });
    dp.GPIOH.ospeedr.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let shift = 12 * 2;
        bits &= !(0b11 << shift);
        w.bits(bits)
    });
    dp.GPIOH.afrl.modify(|r, w| unsafe {
        let mut bits = r.bits();
        w.bits(bits)
    });
    dp.GPIOH.afrh.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let afr_shift = (12 % 8) * 4;
        bits &= !(0xF << afr_shift);
        bits |= (0u32 & 0xF) << afr_shift;
        w.bits(bits)
    });
    dp.GPIOH.moder.modify(|r, w| unsafe {
        let mut bits = r.bits();
        let shift = 12 * 2;
        bits &= !(0b11 << shift);
        bits |= 0b10 << shift;
        w.bits(bits)
    });
}

/// Disables unused peripherals and masks their interrupts.

/// Enables peripheral clocks for the generated board using PAC registers.

pub fn enable_peripherals(_dp: &pac::Peripherals) {}

/// De-initializes board pins to their analog state.

/// De-initializes board peripherals and clocks using PAC registers.

pub fn deinit_board_pac(dp: &pac::Peripherals) {
    // Return pins to analog and remove pulls/open-drain
    let shift = 15 * 2;
    dp.GPIOD.moder.modify(|r, w| unsafe {
        let mut bits = r.bits() & !(0b11 << shift);
        bits |= 0b11 << shift;
        w.bits(bits)
    });
    dp.GPIOD
        .pupdr
        .modify(|r, w| unsafe { w.bits(r.bits() & !(0b11 << shift)) });
    dp.GPIOD
        .otyper
        .modify(|r, w| unsafe { w.bits(r.bits() & !(1 << 15)) });
    let shift = 4 * 2;
    dp.GPIOD.moder.modify(|r, w| unsafe {
        let mut bits = r.bits() & !(0b11 << shift);
        bits |= 0b11 << shift;
        w.bits(bits)
    });
    dp.GPIOD
        .pupdr
        .modify(|r, w| unsafe { w.bits(r.bits() & !(0b11 << shift)) });
    dp.GPIOD
        .otyper
        .modify(|r, w| unsafe { w.bits(r.bits() & !(1 << 4)) });
    let shift = 11 * 2;
    dp.GPIOE.moder.modify(|r, w| unsafe {
        let mut bits = r.bits() & !(0b11 << shift);
        bits |= 0b11 << shift;
        w.bits(bits)
    });
    dp.GPIOE
        .pupdr
        .modify(|r, w| unsafe { w.bits(r.bits() & !(0b11 << shift)) });
    dp.GPIOE
        .otyper
        .modify(|r, w| unsafe { w.bits(r.bits() & !(1 << 11)) });
    let shift = 12 * 2;
    dp.GPIOH.moder.modify(|r, w| unsafe {
        let mut bits = r.bits() & !(0b11 << shift);
        bits |= 0b11 << shift;
        w.bits(bits)
    });
    dp.GPIOH
        .pupdr
        .modify(|r, w| unsafe { w.bits(r.bits() & !(0b11 << shift)) });
    dp.GPIOH
        .otyper
        .modify(|r, w| unsafe { w.bits(r.bits() & !(1 << 12)) });

    // Gate peripheral clocks

    // Disable DMA controllers and mask their interrupts

    // Disable interrupts
}
