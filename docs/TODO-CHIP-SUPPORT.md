<!--
Tracks tasks for the Chip & Board Support workstream.
-->
# Chip & Board Support Workstream TODO

## Purpose
Unify chip and board configuration data into self-contained crates per vendor so that `rlvgl-creator` and its UI can dynamically populate drop-downs of vendors, microcontrollers and boards. Today the creator references a single `.ioc` or CSV file directly; this work stream extracts all supported devices into dedicated vendor crates and wires them into the build and publish pipeline.

## Intermediate Representation (IR) Plan
- Standardise on a unified IR shared by vendor crates and `rlvgl-creator`.
- Canonical device definitions live under `mcu/` and are scraped from vendor XML sources (e.g. the `STM32_open_pin_data` submodule’s `mcu/` and `ip/` trees).
- Board overlays are stored under `boards/` and are produced by converting `.ioc` examples or user-supplied CubeMX files using the canonical `mcu` data.
- Both `mcu` and `boards` datasets are bundled with creator, which also exposes a converter for arbitrary `.ioc` files.

## Pre-setup Instructions
1. **Establish vendor crate locations**
   - Create a new top-level directory (e.g. `chipdb/`) or reuse an existing `support/` subfolder to house vendor crates. Each vendor gets its own crate, such as `rlvgl-stm-pins` for STMicroelectronics devices, `rlvgl-nrf-pins` for Nordic, `rlvgl-esp-pins` for Espressif, `rlvgl-nxp-pins` for NXP, `rlvgl-silabs-pins` for Silicon Labs, `rlvgl-microchip-pins` for Microchip, `rlvgl-renesas-pins` for Renesas, `rlvgl-ti-pins` for Texas Instruments, and `rlvgl-rp2040-pins` for generic RP2040 support. All crates live under the workspace and share the same edition while carrying vendor-specific license files.
   - Include a `README.md` in each vendor crate describing the embedded board database format and how the crate integrates with `rlvgl-creator` so that it can be used independently.
2. **Add workspace members**
   - Update the root `Cargo.toml` `[workspace]` section to include the new vendor crates. This ensures they are compiled and published along with the rest of the repository.
   - For each vendor crate add a bare-bones `Cargo.toml` with:
     ```toml
     [package]
     name = "rlvgl-stm-pins"
     version = "0.0.1"
     edition = "2021"
     publish = true
     license = "BSD-3-Clause" # adjust per vendor

     [lib]
     crate-type = ["rlib"]

     [dependencies]
     serde = { version = "1", features = ["derive"], optional = true }
     ```
     You can derive a similar template for other vendors. The optional `serde` feature allows the crate to optionally serialise/deserialise its board database.
3. **Vendor data submodules & licensing**
   - Store vendor source configuration files only as git submodules under `vendor/` to avoid redistributing third-party data.
   - Ignore generated databases (e.g. `crates/rlvgl-stm-pins/src/**`) via `.gitignore`; they are produced during build or publish.
   - Each vendor crate carries its own `LICENSE` file matching the vendor’s requirements (e.g. BSD-3 for ST) while the repository root remains MIT and lists vendor crates in `LICENSE-THIRD-PARTY.md`.
   - Provide `tools/build_vendor.sh` and `tools/gen_pins.py` to initialise submodules, convert vendor files into canonical outputs, stamp the appropriate license, and populate the vendor crate prior to `cargo build` or `cargo publish`.
   - For STM32 support, add the `STM32_open_pin_data` repository as a submodule and scrape its XML. Convert `mcu/` and `ip/` into canonical `mcu` IR and translate bundled `.ioc` files into `boards` overlays.
4. **Bootstrapping `build.rs` for asset embedding**
   - Each vendor crate should contain a `build.rs` script that locates the extracted board definition files (generated by the conversion tools above) and embeds them into the binary using `include_bytes!` or a custom archive builder. Use an environment variable (e.g. `RLVGL_CHIP_SRC`) to point to the directory of extracted definitions at build time. The build script can then iterate over that directory, compress or pack the files into a single archive (e.g. tar or zip), and emit a Rust source file that exposes a static `VENDOR_DB: &'static [u8]` or a typed wrapper around it.
   - Write a small wrapper API in `lib.rs` that exposes helper functions:
     - `fn vendor() -> &'static str` – returns the vendor name used by the UI.
     - `fn boards() -> &'static [BoardInfo]` – returns a list of available boards and microcontrollers.
     - `fn find(board_name: &str) -> Option<&'static BoardInfo>` – lookup by exact board or chip name.
   - A `BoardInfo` struct should include at minimum: board name, chip name, package, pin configuration blob offset/length and maybe a description.
5. **Extend the Python extraction tool**
   - The existing `tools/st_extract_af.py` extracts `.ioc` files under `chips/stm/...` into a normalised format. Extend this script to handle both `.ioc` and `.csv` sources. Detect the file type by extension; parse `.csv` pin descriptions into the same intermediate representation used for `.ioc` files (a JSON or YAML dictionary keyed by pin name and function). The output should be a single JSON or YAML file per board containing all pins, metadata, and the board/chip names. Place the generated files into a build cache directory (e.g. `build/chipdb/stm`).
   - Provide a command-line interface: `python tools/st_extract_af.py --input path/to/board_dir --output build/chipdb/stm`. Document usage in the script header and in this TODO; update `README.md` if needed.
   - Add unit tests for the parser that feed sample `.ioc` and `.csv` files and assert on the resulting dictionary keys/values. Place these tests under `tests/tools_st_extract_af.rs` so they run in CI.
6. **Update the publish workflow**
   - Modify the GitHub Actions or GitLab CI configuration to run `tools/build_vendor.sh` before packaging the vendor crates. The script should initialise submodules, invoke `tools/gen_pins.py`/`tools/st_extract_af.py` with appropriate input/output directories, and then set `RLVGL_CHIP_SRC` for the subsequent `cargo publish` step.
   - Ensure that the vendor crates are versioned and published whenever the generation output changes. Use `cargo publish --dry-run` to validate before release.

## Tasks
### Level 1 – Vendor crate scaffolding
- [x] **Create rlvgl-stm-pins crate** – Set up the first vendor crate: directory, `Cargo.toml` (license = BSD-3-Clause), `build.rs`, `lib.rs` skeleton, and `README.md` describing usage and format. Depends on: Pre-setup
- [x] **Create rlvgl-…-pins crates** – For each additional vendor identified (Nordic, Espressif, NXP, Silicon Labs, Microchip, Renesas, Texas Instruments, generic RP2040), copy the STM template, including the `README.md` and appropriate license text, and adjust package names. Depends on: STM crate
- [x] **Generation scripts** – Provide `tools/gen_pins.py` and `tools/build_vendor.sh` to fetch submodules, convert vendor data, stamp license files, and populate the vendor crates before building. Document usage in `README.md`. Depends on: Vendor crate scaffolding
- [x] **Implement BoardInfo API** – Define the `BoardInfo` struct and helper functions (`vendor`, `boards`, `find`) in each vendor crate. Depends on: STM crate
- [x] **Embed extracted definitions** – Write build logic to read the JSON/YAML files produced by `gen_pins.py`/`st_extract_af.py` and pack them into the binary. Depends on: Python tool
- [x] **Unit tests for vendor crates** – Add tests verifying that `boards()` returns the expected number of entries and that `find()` resolves known names. Depends on: API impl

### Level 2 – Python extraction & conversion
- [x] **STM32 XML scraper** – Parse `STM32_open_pin_data` `mcu/` and `ip/` directories into canonical `mcu` IR. Depends on: Pre-setup
- [x] **Ignore undefined MCUs** – Update `stm32_xml_scraper.py` to skip MCUs without definitions so full `.ioc` conversions do not fail. Depends on: STM32 XML scraper
- [x] **.ioc overlay generation** – Populate IR JSON with pin data when converting `.ioc` files into `boards` entries using the canonical `mcu` data. Depends on: STM32 XML scraper
- [x] **User .ioc conversion** – Provide a CLI that accepts a CubeMX `.ioc` and emits a `boards` overlay for custom configurations. Depends on: .ioc overlay generation
- [x] **CSV parser integration** – Extend `tools/st_extract_af.py` to parse CSV pin descriptions into the same intermediate representation. Depends on: Pre-setup
- [x] **Unified output format** – Ensure both `.ioc` and `.csv` sources produce a consistent JSON/YAML schema used by the vendor crates. Depends on: CSV parser
- [x] **Command-line interface** – Add CLI flags for input directory, output directory and vendor name. Depends on: Unified format
- [x] **Sample file tests** – Add automated tests in Rust or Python that process sample `.ioc` and `.csv` files and compare against expected snapshots. Depends on: CSV parser
- [x] **Documentation** – Document the usage of the script and the expected file formats in the repository’s `README.md` and in this TODO. Depends on: CLI

### Level 2a – IR ➜ Rust initialisation alignment
- [ ] **Canonical pin context** – Define a per-pin schema including `name`, `port`, `index`, `class`, `sig_full`, `instance`, `signal`, `af`, `mode`, `pull`, `speed`, `otype`, `label`, `is_exti`, and `exti_line` while retaining existing MCU fields.
- [ ] **Lookup table normalisation** – Map Cube strings for mode, pull, speed and otype into bitfield values and HAL-friendly enums.
- [ ] **Template generation rules** – Encode Peripheral, GPIO and System class rules and provide HAL and PAC output patterns based on the canonical context.
- [ ] **EXTI handling** – Add fields for EXTI port indices and trigger configuration so templates can set up SYSCFG and EXTI registers correctly.

### Level 3 – Creator integration
- [x] **Expose canonical IR** – Update creator to load `mcu` definitions alongside `boards` overlays and surface both in the UI and CLI. Depends on: STM32 XML scraper
- [x] **Custom .ioc import** – Add a conversion flow in creator allowing users to import their own CubeMX `.ioc` files. Depends on: Expose canonical IR
- [x] **Add vendor crate dependencies** – Update `rlvgl-creator`'s `Cargo.toml` to depend on each vendor crate via path or workspace. Depends on: Vendor crates
- [x] **Public API to enumerate boards** – Add functions in creator to iterate over all vendor crates and build a flat list of Vendor → Boards entries. Depends on: Vendor API
- [x] **UI drop-down support** – On the creator branch’s UI (see `rlvgl/creator-ui`), update the board selection component to present vendor, chip and board options loaded from the crates. Depends on: Enumeration API
- [x] **Exact name matching** – Ensure that the UI selection uses exact matching to find board definitions in the vendor crates. Depends on: UI support
- [x] **Fallback / error handling** – Define behaviour when a vendor crate or board is missing; display a clear message rather than panicking. Depends on: UI support

### Level 4 – Publish & CI integration
- [x] **CI extraction step** – Add a CI job that runs `tools/build_vendor.sh` against the vendor submodules. Depends on: Python CLI
- [x] **Environment variable wiring** – Pass `RLVGL_CHIP_SRC` or similar environment variables into the vendor crate build to locate the generated files. Depends on: CI extraction
- [x] **Cargo publish matrix** – Extend the release workflow to publish each vendor crate along with core, ui, and other crates. Depends on: Vendor crates
- [x] **Version bump automation** – Write a script or adopt `cargo release` to bump versions across vendor crates when new definitions are generated. Depends on: Publish matrix
- [x] **Update docs and changelog** – Add release notes summarising supported chips/boards and instructions for using the new crates with creator. Depends on: Publish matrix

## Codex Playbook — STM32 Open Pin Data ➜ Canonical JSON (lossless + canonical)
Track a new Python-based pipeline (`afdb`) that converts STM32 vendor XML into lossless and canonical JSON. Facts: ST ships no public XSD for per-MCU or IP XML, so we ingest raw data and validate the canonical overlay with local JSON Schemas.
- [x] **Phase 0 – Repo scaffold & deps** – Create `tools/afdb` package with CLI, schemas, fixtures, and minimal `pyproject.toml`.
- [x] **Phase 1 – Lossless XML ingest** – Implement `ingest_raw.py` and `util_xml.py` to parse XML safely into raw JSON trees preserving order, attributes, and line numbers.
- [x] **Phase 2 – Canonical MCU overlay** – Build `parse_mcu.py` to overlay structured MCU data (meta, instances, pins) while retaining the raw snapshot.
- [x] **Phase 3 – Canonical IP overlay** – Write `parse_ip.py` to normalize IP `_Modes.xml` files into peripheral signal dictionaries.
- [x] **Phase 4 – Catalog builder** – Fuse MCU and IP overlays via `build_catalog.py`, producing per-part catalogs keyed by pins and instances.
- [x] **Phase 5 – JSON Schemas** – Define `schemas/mcu_canonical.schema.json` and `schemas/ip_canonical.schema.json` to validate canonical outputs.
- [x] **Phase 6 – CLI wiring** – Expose `afdb` subcommands (`import-mcu`, `import-ip`, `build-catalog`) that emit canonical JSON.
- [x] **Phase 7 – Tests** – Add fixture-driven `pytest` suites covering ingest, MCU/IP parsing, and catalog building.
- [x] **Phase 8 – Reports** – Generate optional human-readable pin/function tables under `reports/`.
- [x] **Phase 9 – Integration hooks** – Store generated catalogs under `afdb/<family>/<refname>.json` and retain `raw_xml_path` for provenance.

#### Ready-to-run prompts
- Prompt A – scaffold & dependencies
- Prompt B – implement `parse_ip.py` and `build_catalog.py`
- Prompt C – add JSON Schemas and tests
- Prompt D – wire CLI and demonstrate end-to-end run

#### Notes on field retention
- Every input element or attribute persists either in the raw snapshot or in an `other_attributes` map on the canonical nodes.
- Child order is preserved via `raw_tree.children[]`, and duplicate scalar tags become arrays in the canonical overlay.
- Namespaces are stored in `qname.ns` so provenance can always be traced back to the vendor XML.

### STM32 data crate size plan
- [x] Optimise the 11.4 MB zipped MCU XML into a compact IR and Zstd artifact targeting ≤ 4–6 MB per family.
- [x] Shard runtime data by MCU family (e.g. `stm32-data-f`, `stm32-data-h`) embedding a single `.bin.zst` per crate.
- [ ] Re‑evaluate the need for further splits if size limits are still tight.

## Definition of Done
- All vendor crates compile and expose a stable API returning board definitions.
- The Python extraction script can parse both `.ioc` and `.csv` and produces consistent outputs; tests cover representative samples.
- `rlvgl-creator` can list vendors, chips and boards via the new crates, and the UI drop-downs populate correctly.
- CI runs extraction and publishes updated vendor crates; version numbers bump automatically when definitions change.
- Documentation in `README.md` and this TODO is up to date, and `docs/TEST-TODO.md` includes new test IDs covering chip support (e.g. T-19 for vendor enumeration, T-20 for board loading smoke test).
- Canonical `mcu` and `boards` IR derived from `STM32_open_pin_data` is consumable through `rlvgl-creator`, which can also convert user-supplied `.ioc` files.
- Each STM32 data crate embeds a compressed `.bin.zst` artifact per MCU family and stays well under the 10 MB publish limit.
